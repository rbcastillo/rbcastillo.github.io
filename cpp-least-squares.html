<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
	<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">

    <title>C++ | Least squares</title>
    <meta content="" name="description">
    <meta content="" name="keywords">
	
	<!-- Google Site Verification -->
    <meta name="google-site-verification" content="DCSbtcds2oWXGOsnqmm7Q_wLuvkTXY1h2-DgVP8euTg" />
	
	<!-- Favicons -->
    <link href="assets/img/RubenCloseupRound.png" rel="icon">
    <link href="assets/img/RubenCloseupRound.png" rel="apple-touch-icon">

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|JetBrains+Mono" rel="stylesheet">
	
    <!-- Template Main CSS File -->
    <link href="assets/css/style.css" rel="stylesheet">
	<link href="assets/css/code-format.css" rel="stylesheet">
	
	<!-- highlight.js script to format code -->
	<script src="assets/js/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	
	<!-- mathjax script to format mathematical expressions -->
	<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>

	
	<!-- Load HTML template elements -->
	<script src="assets/js/add_header.js" type="text/javascript" defer></script> <!-- Header -->
	
	<!-- Vendor CSS Files -->
    <link href="assets/vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
	

    <!-- =======================================================
    * Template Name: iPortfolio - v3.1.0
    * Template URL: https://bootstrapmade.com/iportfolio-bootstrap-portfolio-websites-template/
    * Author: BootstrapMade.com
    * License: https://bootstrapmade.com/license/
    ======================================================== -->
</head>

<body>

<!-- ======= Mobile nav toggle button ======= -->
<i class="bi bi-list-ul mobile-nav-toggle d-xl-none"></i>

<main id="main">

	<div class="challenge-description">
	<p>C++ | <span class="challenge-name">Least squares</span></p>
	</div>
	
    <!-- ======= Challenge introduction section ======= -->
    <section id="challenge-introduction" class="challenge-section">
        <div class="container">

            <div class="section-title">
                <h2>Challenge introduction</h2>

                <p>This challenge provides valuable practice as it combines various mathematical concepts, data handling, and computational techniques. By requiring 
				the use of the least squares method to fit a second-degree polynomial to a dataset, it encourages the application of <strong>linear algebra</strong> 
				and <strong>matrix operations</strong> practically. Additionally, the task involves reading data from an external file, which introduces <strong>file 
				handling</strong> and <strong>input/output operations</strong>. Moreover, dealing with potential <strong>singularity issues</strong> in the coefficient 
				matrix further tests <strong>error handling</strong> skills. In summary, this problem encompasses a wide range of mathematical and programming skills in 
				both mathematical and computational domains.</p>
				
				<p>The problem is sourced from the <strong>programming languages</strong> subject from <strong>UNED</strong> and is available at the following 
				<strong><a href="https://www2.uned.es/6102210/" target="_blank" style="color:#02CE55;">link</a></strong>. 
				I recommend attempting to solve the challenge independently before reviewing the provided solution.</p>


            </div>

        </div>
    </section><!-- End challenge introduction section -->
	
	<!-- ======= Problem statement section ======= -->
    <section id="problem-statement" class="challenge-section">
        <div class="container">

            <div class="section-title">
                <h2>Problem statement</h2>

                <p>The goal is to calculate, using the <strong>least squares method</strong>, the following second-degree polynomial:</p>
				<p>&emsp;&emsp;&emsp;&emsp;\(y = b_{0} + b_{1} · x + b_{2} · x^2\)</p>
				<p>that best fits a dataset \((x_1, y_1), . . . , (x_n, y_n)\) stored in a text file. The pairs of values \((x_i, y_i)\) are 
				<strong>real numbers</strong>. The coefficients of the polynomial \((b_0, b_1, b_2)\) are computed by solving the following system 
				of <strong>three linear equations</strong> with <strong>three unknowns</strong>:</p>				
				<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;\(\displaystyle b_0 · n + b_1 · \sum_{j=1}^{n}x_j + b_2 · \sum_{j=1}^{n}x^2_j = \sum_{j=1}^{n}y_j \)</p>
				<p>&emsp;&emsp;&emsp;&emsp;\(\displaystyle b_0 · \sum_{j=1}^{n}x_j + b_1 · \sum_{j=1}^{n}x^2_j + b_2 · \sum_{j=1}^{n}x^3_j = \sum_{j=1}^{n}x_j · y_j \)</p>
				<p>&emsp;&emsp;&emsp;&emsp;\(\displaystyle b_0 · \sum_{j=1}^{n}x^2_j + b_1 · \sum_{j=1}^{n}x^3_j + b_2 · \sum_{j=1}^{n}x^4_j = \sum_{j=1}^{n}x^2_j · y_j \)</p>
				<p>The data file \((x_1, y_1), . . . , (x_n, y_n)\) has n rows and 2 columns. The i-th row contains \(x_i\) in the first column and \(y_i\) in the second. 
				Write a C++ program that performs the following actions:</p>
				<ol>
					<li>Display a message on the console, asking the user to enter the name of the text file where the data is stored. 
					Read the filename from the console.</li>
					<li>Open the file for reading. If an error occurs, terminate.</li>
					<li>Read the file, storing the values in two <strong>double-type vectors</strong> named \(vX\) and \(vY\).</li>
					<li>Solve the system of equations. To do this, calculate the <strong>inverse of the coefficient matrix</strong> of the system. 
					If the matrix is singular, terminate.</li>
					<li>Display the adjusted polynomial on the console, with numeric values in scientific notation and 4 digits of precision.</li>
					<li>Terminate.</li>
				</ol>

            </div>

        </div>
    </section><!-- End problem statement section -->

	<!-- ======= Solution section ======= -->
    <section id="solution" class="challenge-section">
        <div class="container">

            <div class="section-title">
                <h2>Solution</h2>

                <p>In approaching this problem, <strong>the emphasis has been on simplicity</strong>, leveraging the <strong>explicit structure</strong> of the 
				problem rather than developing generalized functions for mathematical techniques that could be applied to other scenarios. This simplification 
				is particularly evident in the functions defining the coefficient matrix and the constant vector, which <strong>directly translate</strong> the 
				equations from the problem statement instead of pursuing broader, more abstract approaches. However, in certain operations, such as matrix inversion, 
				functions suitable for matrices of any dimension have been employed, making use of <strong>recursive properties</strong>.</p>
				
				<p>Concerning the technical aspects of solving this problem, the <strong>determinant method</strong> was selected for computing the inverse of the coefficient 
				matrix. While this method may be <strong>less computationally efficient</strong> than alternatives like the <strong>Gauss-Jordan method</strong> for 
				larger matrices, it performs well for our 2x2 or 3x3 matrices, resulting in only a <strong>minor loss of efficiency</strong>. Therefore, the determinant 
				method was chosen due to its compatibility with a <strong>straightforward recursive implementation</strong>.</p>
				
				<pre><code class="cpp">
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &lt;map&gt;
#include &lt;stdexcept&gt;
#include &lt;sstream&gt;

double sum_vector_to_nth_power(std::vector &lt;double&gt; input_vector, int power) {
    double sum_value = 0;
    std::vector&lt;double&gt;::iterator it;
    for (it = input_vector.begin(); it &lt; input_vector.end(); it++) {
        sum_value += std::pow(*it, power);
    }
    return sum_value;
}

double dot_product_y_and_x_to_power(std::vector &lt;double&gt; x, std::vector &lt;double&gt; y, int x_power) {
    double dot_product = 0;
    std::vector&lt;double&gt;::iterator it_x = x.begin();
    std::vector&lt;double&gt;::iterator it_y = y.begin();
    for (int i = 0; i &lt; x.size(); i++) {
        dot_product += *(it_y + i) * std::pow(*(it_x + i), x_power);
    }
    return dot_product;
}

int check_matrix_is_square(std::vector &lt;std::vector &lt;double&gt;&gt; input_matrix) {
    if (input_matrix.size() != input_matrix[0].size()) {
        std::stringstream ss;
        ss &lt;&lt; "The input matrix is not square";
        throw std::invalid_argument(ss.str());
    }
    return 1;
}

// We create a function to generate the coefficients matrix
//     | Σ(x_i)^0   Σ(x_i)^1   Σ(x_i)^2 |
//     | Σ(x_i)^1   Σ(x_i)^2   Σ(x_i)^3 |
//     | Σ(x_i)^2   Σ(x_i)^3   Σ(x_i)^4 |
std::vector &lt;std::vector &lt;double&gt;&gt; calculate_coefficients_matrix(std::vector &lt;double&gt; vX) {
    std::vector &lt;std::vector &lt;double&gt;&gt;  coefficients_matrix(3, std::vector&lt;double&gt;(3));
    for (int i = 0; i &lt; 3; i++) {
        for (int j = 0; j &lt; 3; j++) {
            coefficients_matrix[i][j] = sum_vector_to_nth_power(vX, i + j);
        }
    }
    return coefficients_matrix;
}

// We create a function to generate the vector of constants
//     | Σ[(x_i)^0·(y_i)] |
//     | Σ[(x_i)^1·(y_i)] |
//     | Σ[(x_i)^2·(y_i)] |
std::vector &lt;double&gt; calculate_constants_vector(std::vector &lt;double&gt; vX, std::vector &lt;double&gt; vY) {
    std::vector &lt;double&gt;  constants_matrix(3);
    for (int i = 0; i &lt; 3; i++) {
        constants_matrix[i] = dot_product_y_and_x_to_power(vX, vY, i);
    }
    return constants_matrix;
}

std::vector &lt;std::vector &lt;double&gt;&gt; extract_minor(std::vector &lt;std::vector &lt;double&gt;&gt; matrix,
                                                 int row, int column)
throw (std::invalid_argument) {
    try {
        check_matrix_is_square(matrix);
    }
    catch (std::invalid_argument& exception) {
        std::stringstream ss;
        ss &lt;&lt; "The matrix is not square, minors cannot be extracted";
        throw std::invalid_argument(ss.str());
    }
    double size = matrix.size();
    std::vector &lt;std::vector &lt;double&gt;&gt;  minor(size - 1, std::vector&lt;double&gt;(size - 1));
    int ref_row = 0, ref_col = 0;
    for (int i = 0; i &lt; size; i++) {
        if (i != row) {
            for (int j = 0; j &lt; size; j++) {
                if (j != column) {
                    minor[ref_row][ref_col] = matrix[i][j];
                    ref_col++;
                }
            }
            ref_col = 0;
            ref_row++;
        }                
    }
    return minor;
}

double calculate_determinant(std::vector &lt;std::vector &lt;double&gt;&gt; matrix) 
throw (std::invalid_argument) {
    try {
        check_matrix_is_square(matrix);
    }
    catch (std::invalid_argument& exception) {
        std::stringstream ss;
        ss &lt;&lt; "The matrix is not square, the determinant cannot be calculated";
        throw std::invalid_argument(ss.str());
    }
    double determinant = 0;
    int size = matrix.size();
    if (size == 1) {
        determinant = matrix[0][0];
        return determinant;
    }
    std::vector &lt;std::vector &lt;double&gt;&gt; minor;
    int sign = 1;
    for (int row = 0; row &lt; size; row++) {
        minor = extract_minor(matrix, row, 0);
        determinant += sign * matrix[row][0] * calculate_determinant(minor);
        sign = -sign;
    }
    return determinant;
}

std::vector &lt;std::vector &lt;double&gt;&gt; calculate_adjoint(std::vector &lt;std::vector &lt;double&gt;&gt; matrix) 
throw (std::invalid_argument) {
    try {
        check_matrix_is_square(matrix);
    }
    catch (std::invalid_argument& exception) {
        std::stringstream ss;
        ss &lt;&lt; "The matrix is not square, its adjoint cannot be calculated";
        throw std::invalid_argument(ss.str());
    }
    int size = matrix.size();
    std::vector &lt;std::vector &lt;double&gt;&gt; adjoint(size, std::vector&lt;double&gt;(size));
    if (size == 1) {
        adjoint[0][0] = 1;
        return adjoint;
    }
    int sign = 1;
    std::vector &lt;std::vector &lt;double&gt;&gt; minor;
    for (int row = 0; row &lt; size; row++) {
        for (int col = 0; col &lt; size; col++) {
            sign = ((row + col) % 2 == 0) ? 1 : -1;
            minor = extract_minor(matrix, row, col);
            // Swap row and col references to transpose the array
            adjoint[col][row] = sign * calculate_determinant(minor);
        }
    }
    return adjoint;
}

std::vector &lt;std::vector &lt;double&gt;&gt; calculate_inverse(std::vector &lt;std::vector &lt;double&gt;&gt; matrix)
throw (std::invalid_argument) {
    try {
        check_matrix_is_square(matrix);
    }
    catch (std::invalid_argument& exception) {
        std::stringstream ss;
        ss &lt;&lt; "The matrix is not square, it cannot be inverted";
        throw std::invalid_argument(ss.str());
    }
    double determinant = calculate_determinant(matrix);
    if (determinant == 0) {
        std::stringstream ss;
        ss &lt;&lt; "The matrix is singular (zero determinant), its inverse cannot be calculated";
        throw std::invalid_argument(ss.str());
    }
    int size = matrix.size();
    std::vector &lt;std::vector &lt;double&gt;&gt; adjoint = calculate_adjoint(matrix);
    std::vector &lt;std::vector &lt;double&gt;&gt; inverse(size, std::vector&lt;double&gt;(size));
    for (int row = 0; row &lt; size; row++) {
        for (int col = 0; col &lt; size; col++) {
            inverse[row][col] = adjoint[row][col] / determinant;
        }
    }
    return inverse;
}

// We obtain the fitted polinomial as X^(-1)Y 
// Where X^(-1) is the inverse of the coefficients matrix and Y is the constants vector
std::vector &lt;double&gt; get_polinomial_fit(std::vector &lt;std::vector &lt;double&gt;&gt; coefficients_inverse, 
                                        std::vector &lt;double&gt; constants_vector)
throw (std::invalid_argument) {
    if (coefficients_inverse[0].size() != constants_vector.size()) {
        std::stringstream ss;
        ss &lt;&lt; "Input shapes are not compatible with multiplication";
        throw std::invalid_argument(ss.str());
    }
    std::vector &lt;double&gt; polynomial_coefficients;
    double coefficient;
    int n_rows = coefficients_inverse.size(), n_cols = coefficients_inverse[0].size();
    for (int row = 0; row &lt; n_rows; row++) {
        coefficient = 0;
        for (int col = 0; col &lt; n_cols; col++) {
            coefficient += coefficients_inverse[row][col] * constants_vector[col];
        }
        polynomial_coefficients.push_back(coefficient);
    }
    return polynomial_coefficients;
}

void print_polynomial(std::vector &lt;double&gt; polynomial_coefficients) {
    std::map&lt;int, std::string&gt; x_text;
    x_text[0] = ""; x_text[1] = "x"; x_text[2] = "x^2";
    std::string add_sign = "", subtract_sign = "- ";
    std::cout &lt;&lt; "\nFitted polynomial:" &lt;&lt; std::endl;
    std::cout &lt;&lt; std::scientific &lt;&lt; std::setprecision(4) &lt;&lt; "y = ";
    for (int i = 0; i &lt; polynomial_coefficients.size(); i++) {
        double coefficient = polynomial_coefficients[i];
        if (coefficient &ge; 0) {
            std::cout &lt;&lt; add_sign &lt;&lt; coefficient &lt;&lt; x_text[i];
        }
        else {
            std::cout &lt;&lt; subtract_sign &lt;&lt; -coefficient &lt;&lt; x_text[i];
        }
        add_sign = " + ";
        subtract_sign = " - ";
    }
    std::cout &lt;&lt; std::endl;
}

int main() {
    std::string file_name;
    std::cout &lt;&lt; "Name of the file to be uploaded: ";
    std::getline(std::cin, file_name);
    std::ifstream f(file_name, std::ios::in);
    if (!f) {
        std::cout &lt;&lt; "An error occurred while opening the file" &lt;&lt; std::endl;
        return 1;
    }
    double x_i, y_i;
    std::vector &lt;double&gt; vX, vY;
    while (f &gt;&gt; x_i &gt;&gt; y_i) {
        vX.push_back(x_i);
        vY.push_back(y_i);
    }
    std::vector &lt;std::vector &lt;double&gt;&gt; coefficients_matrix;
    coefficients_matrix  = calculate_coefficients_matrix(vX);
    try {
        std::vector &lt;std::vector &lt;double&gt;&gt; coefficients_inverse;
        coefficients_inverse = calculate_inverse(coefficients_matrix);
        std::vector &lt;double&gt; constants_vector = calculate_constants_vector(vX, vY);
        std::vector &lt;double&gt; polynomial_coefficients;
        polynomial_coefficients = get_polinomial_fit(coefficients_inverse, constants_vector);
        print_polynomial(polynomial_coefficients);
    }
    catch (std::invalid_argument& exception) {
        std::cout &lt;&lt; exception.what() &lt;&lt; std::endl;
        return -1;
    }
    return 0;
}
				</code></pre>
				
            </div>

        </div>
    </section><!-- End solution section -->
	
</main>

<!-- Template Main JS File -->
<script src="assets/js/main.js"></script>

</body>

</html>